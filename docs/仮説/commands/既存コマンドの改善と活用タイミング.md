# 既存コマンドの改善と活用タイミング

## 仮説の概要
運用中のカスタムコマンドを実際の使用頻度と効果に基づいて改善することで、日常の開発作業をさらに効率化できる。特に高頻度で使用するコマンドのワークフロー最適化と、有用だが使用タイミングが不明確なコマンドの活用場面の明確化が重要。

## 各コマンドの改善ポイント

### 1. /reset の簡略化

#### 現状の問題
- Git操作だけなのに報告処理が冗長
- シンプルな操作に不要な出力

#### 改善案
```markdown
# 改善前
1. git statusを実行し更新漏れがないことを確認
2. git switch mainを実行
3. git pullを実行
4. 更新内容を簡単に報告 ← 不要

# 改善後
1. git switch main
2. git pull
# 必要最小限の操作のみ、報告は省略
```

### 2. /similarity-ts の活用タイミング明確化

#### 現状の問題
- 有用だが「いつ使うか」が不明確
- 定期実行のトリガーがない

#### 活用タイミングの提案
```markdown
## 自動実行トリガー
1. PRマージ前の最終チェック
2. 週次の定期コード品質チェック
3. 大規模機能追加後の整理

## 手動実行の判断基準
- 同じような処理を3回以上書いた時
- ファイル数が100を超えたプロジェクト
- "コピペした"という意識があった時

## 実行後のアクション
1. 閾値（例：類似度70%以上）を超えたら即リファクタリング
2. 共通化の優先順位をスコアで判定
3. 技術的負債として Issue 化
```

### 3. /ci-check の高度化

#### 現状の問題
- 高頻度使用なのにワークフローが基本的すぎる
- エラーパターンの学習機能がない

#### 改善案
```markdown
## ワークフロー改善
1. **エラーパターン認識**
   - よくあるエラーをパターン化
   - 過去の解決策を提案

2. **並列実行の強化**
   - ローカルでの再現とログ解析を同時実行
   - 複数のジョブ失敗を一度に対処

3. **予防的チェック**
   - push前にローカルで簡易チェック
   - 頻出エラーの事前警告

## エラーパターンDB
- TypeScript型エラー → 型定義の見直し
- テスト失敗 → モックの更新確認
- Lint エラー → 自動修正可能か判定
- ビルドエラー → 依存関係の確認
```

## プロンプトの書き方提案

### コマンドの使い分けマトリクス

| タイミング | 推奨コマンド | 理由 |
|---------|----------|-----|
| Issue着手時 | /reset → /start-tdd or /start-quick | 環境をクリーンにしてから開始 |
| コミット前 | /similarity-ts（条件付き） | 重複コードの事前チェック |
| PR作成後 | /ci-check | CI失敗の迅速な対応 |
| レビュー後 | /reply-review | 体系的な対応 |
| 定期実行 | /similarity-ts | 技術的負債の可視化 |

### 自動化フローの提案

```yaml
# .github/workflows/code-quality.yml
on:
  pull_request:
    types: [opened, synchronize]
  
jobs:
  similarity-check:
    # PR時に自動で類似コードチェック
    # 結果をPRコメントとして投稿
```

## カスタムコマンドの活用案

### 1. コマンドチェーン
```bash
# 新機能開発の標準フロー
/reset && /start-tdd

# PR前の品質チェック
/similarity-ts && /check-quality
```

### 2. 条件付き実行
```markdown
# similarity-ts に追加
if (ファイル数 > 50 || 最終実行から7日経過) {
  自動実行を提案
}
```

### 3. 実行履歴の活用
```markdown
# ci-check に追加
過去のエラーと解決策を記録
類似エラーで過去の解決策を提示
```

## 期待される効果

1. **/reset の効率化**
   - 実行時間の短縮（報告処理削除）
   - より頻繁な使用を促進

2. **/similarity-ts の定着**
   - 明確な実行タイミング
   - 技術的負債の定量化

3. **/ci-check の高精度化**
   - エラー解決時間の短縮
   - 繰り返しエラーの予防

## 検証すべき項目

1. **使用頻度の変化**
   - 改善前後の実行回数比較
   - 特に similarity-ts の活用率

2. **効率性の測定**
   - タスク完了時間の短縮率
   - エラー解決までの時間

3. **ユーザビリティ**
   - コマンドの直感性
   - 新規ユーザーの習得速度

## メモ

### 優先度
1. **最優先**: /ci-check の改善（使用頻度最高）
2. **高**: /similarity-ts の活用場面明確化
3. **中**: /reset の簡略化

### 段階的改善
- Phase 1: 既存コマンドの最適化
- Phase 2: エラーパターン学習機能
- Phase 3: コマンド間連携の自動化

### 長期的展望
- AI によるコマンド実行タイミングの提案
- プロジェクト特性に応じた自動カスタマイズ
- チーム全体の実行パターン分析